<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•è¯èƒŒè¯µåŠ©æ‰‹ï¼ˆä¸‰åˆ—åˆ†ç±»ç‰ˆï¼‰</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="main-container">
        <!-- å·¦åˆ—ï¼šå·²ç‰¢è®°å•è¯åŒº -->
        <div class="mastered-section">
            <div class="mastered-title">âœ… å·²ç‰¢è®° <span class="count-badge" id="masteredCount">0</span></div>
            <div class="mastered-list" id="masteredList">
                <div class="empty-state">æš‚æ— å·²ç‰¢è®°å•è¯<br>æŒ‰â†é”®å°†ä¸­é—´å•è¯ç§»è‡³æ­¤å¤„</div>
            </div>
        </div>

        <!-- ä¸­é—´åˆ—ï¼šå¾…å·©å›ºå•è¯åŒº -->
        <div class="review-section">
            <div class="review-top-fixed">
                <h1>ğŸ“š å¾…å·©å›º <span class="count-badge" id="reviewCount">0</span></h1>
                <div class="control-bar">
                    <button class="btn" id="hideBtn" disabled>éšè—æ‰€æœ‰é‡Šä¹‰</button>
                    <button class="btn" id="showBtn" disabled>æ˜¾ç¤ºæ‰€æœ‰é‡Šä¹‰</button>
                    <button class="btn reset" id="shuffleBtn" disabled>éšæœºæ‰“ä¹±é¡ºåº</button>
                </div>
                <div class="feedback" id="feedback">â†ï¼šç§»è‡³å·²ç‰¢è®° | â†‘â†“/ç©ºæ ¼/Enterï¼šåˆ‡æ¢ | â†’ï¼šç§»è‡³å¾…è®°å¿†</div>
            </div>

            <div class="review-card-scroll" id="reviewCardScroll">
                <div id="wordCardWrapper">
                    <div class="word-list" id="wordList">
                        <div style="text-align: center; padding: 80px 20px; color: #4299e1; font-size: 20px; line-height: 2;">
                            â³ æ­£åœ¨åŠ è½½å•è¯æ•°æ®...<br>
                            è¯·ç¨å€™ï¼ŒåŠ è½½å®Œæˆåè‡ªåŠ¨æ˜¾ç¤ºå¡ç‰‡
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- å³åˆ—ï¼šå¾…è®°å¿†å•è¯åŒº -->
        <div class="untrained-section">
            <div class="untrained-title">ğŸ“ å¾…è®°å¿† <span class="count-badge" id="untrainedCount">0</span></div>
            <div class="untrained-list" id="untrainedList">
                <div class="empty-state">æš‚æ— å¾…è®°å¿†å•è¯<br>æŒ‰â†’é”®å°†ä¸­é—´å•è¯ç§»è‡³æ­¤å¤„</div>
            </div>
        </div>
    </div>

    <script>
        let words = [];
        let currentIndex = 0;
        let toReviewWords = [];
        let masteredWords = [];
        let untrainedWords = [];
        let latestMasteredIndex = -1;
        let latestUntrainedIndex = -1;
        let isMeaningHidden = false; // å…¨å±€è®°å½•ï¼šä¸­é—´åˆ—é‡Šä¹‰æ˜¯å¦éšè—ï¼ˆå…³é”®ä¿®å¤ï¼‰

        const reviewCardScroll = document.getElementById('reviewCardScroll');
        const masteredList = document.getElementById('masteredList');
        const untrainedList = document.getElementById('untrainedList');
        const masteredCountEl = document.getElementById('masteredCount');
        const reviewCountEl = document.getElementById('reviewCount');
        const untrainedCountEl = document.getElementById('untrainedCount');
        let isAutoScroll = false;
        let scrollTimeout = null;

        // åŠ è½½JSONæ–‡ä»¶
        fetch('Vocabulary.json')
            .then(response => {
                if (!response.ok) throw new Error('æ–‡ä»¶ä¸å­˜åœ¨æˆ–è·¯å¾„é”™è¯¯');
                return response.json();
            })
            .then(data => {
                words = data;
                toReviewWords = [...words];
                updateCounts();
                renderToReviewWords(toReviewWords);
                activateCurrentWord();
                bindEvents();
                enableAllControls();
            })
            .catch(error => {
                document.getElementById('wordList').innerHTML = `
                    <div style="text-align: center; padding: 80px 20px; color: #e53e3e; font-size: 18px; line-height: 2;">
                        âŒ å•è¯æ•°æ®åŠ è½½å¤±è´¥ï¼<br><br>
                        è¯·æ£€æŸ¥ï¼š<br>
                        1. Vocabulary.json æ–‡ä»¶æ˜¯å¦åœ¨åŒæ–‡ä»¶å¤¹<br>
                        2. æ˜¯å¦é€šè¿‡ HTTP åè®®æ‰“å¼€é¡µé¢<br>
                    </div>
                `;
                document.getElementById('feedback').textContent = 'âŒ åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶';
                document.getElementById('feedback').className = 'feedback error';
            });

        // æ¸²æŸ“ä¸­é—´åˆ—å¡ç‰‡ï¼ˆæ¸²æŸ“åæ ¹æ®å…¨å±€çŠ¶æ€æ¢å¤éšè—/æ˜¾ç¤ºï¼‰
        function renderToReviewWords(wordArray) {
            const wordList = document.getElementById('wordList');
            wordList.innerHTML = '';
            if (wordArray.length === 0) {
                wordList.innerHTML = '<div class="empty-state">ğŸ‰ æ‰€æœ‰å¾…å·©å›ºå•è¯å·²åˆ†ç±»å®Œæˆï¼</div>';
                return;
            }

            const fragment = document.createDocumentFragment();
            wordArray.forEach((wordObj, index) => {
                const card = createWordCard(wordObj, index === currentIndex, 'word-card', false, true);
                fragment.appendChild(card);
            });
            wordList.appendChild(fragment);

            // å…³é”®ï¼šæ¸²æŸ“åæ¢å¤ä¹‹å‰çš„éšè—/æ˜¾ç¤ºçŠ¶æ€
            if (isMeaningHidden) {
                hideMiddleTranslations(false); // ä¸é‡å¤æç¤º
            } else {
                showMiddleTranslations(false); // ä¸é‡å¤æç¤º
            }
        }

        // æ¸²æŸ“å·¦åˆ—ï¼šå·²ç‰¢è®°å•è¯
        function renderMasteredWords() {
            masteredList.innerHTML = '';
            if (masteredWords.length === 0) {
                masteredList.innerHTML = '<div class="empty-state">æš‚æ— å·²ç‰¢è®°å•è¯<br>æŒ‰â†é”®å°†ä¸­é—´å•è¯ç§»è‡³æ­¤å¤„</div>';
                latestMasteredIndex = -1;
                return;
            }

            const fragment = document.createDocumentFragment();
            masteredWords.forEach((wordObj, index) => {
                const card = createWordCard(wordObj, false, 'mastered-card', index === latestMasteredIndex, false);
                fragment.appendChild(card);
            });
            masteredList.appendChild(fragment);
            masteredList.scrollTop = masteredList.scrollHeight;
            setTimeout(() => {
                masteredList.scrollTop = masteredList.scrollHeight;
            }, 10);
        }

        // æ¸²æŸ“å³åˆ—ï¼šå¾…è®°å¿†å•è¯ï¼ˆä¿®å¤æœ€æ–°æ ‡è®°ç´¢å¼•é”™è¯¯ï¼‰
        function renderUntrainedWords() {
            untrainedList.innerHTML = '';
            if (untrainedWords.length === 0) {
                untrainedList.innerHTML = '<div class="empty-state">æš‚æ— å¾…è®°å¿†å•è¯<br>æŒ‰â†’é”®å°†ä¸­é—´å•è¯ç§»è‡³æ­¤å¤„</div>';
                latestUntrainedIndex = -1;
                return;
            }

            const fragment = document.createDocumentFragment();
            untrainedWords.forEach((wordObj, index) => {
                // ä¿®å¤ï¼šæœ€æ–°æ ‡è®°ç”¨ latestUntrainedIndexï¼ˆä¹‹å‰è¯¯å†™ä¸º latestMasteredIndexï¼‰
                const card = createWordCard(wordObj, false, 'untrained-card', index === latestUntrainedIndex, false);
                fragment.appendChild(card);
            });
            untrainedList.appendChild(fragment);
            untrainedList.scrollTop = untrainedList.scrollHeight;
            setTimeout(() => {
                untrainedList.scrollTop = untrainedList.scrollHeight;
            }, 10);
        }

        // é€šç”¨åˆ›å»ºå•è¯å¡ç‰‡å‡½æ•°
        function createWordCard(wordObj, isActive, cardClass = 'word-card', isLatest = false, isControlled = false) {
            const card = document.createElement('div');
            card.className = `${cardClass} ${isActive ? 'active' : ''} ${isLatest ? 'latest' : ''}`;
            if (isControlled) card.dataset.controlled = 'true';

            let translationsHtml = '<div class="translations-container">';
            wordObj.translations.forEach(trans => {
                const meanings = trans.translation.split('ï¼›');
                meanings.forEach(mean => {
                    translationsHtml += `
                        <div class="translation-item">
                            <span class="meaning">${mean.trim()}</span>
                            <span class="pos-tag">${trans.type}</span>
                        </div>
                    `;
                });
            });
            translationsHtml += '</div>';

            card.innerHTML = `
                <div class="word-header">
                    <div class="word">${wordObj.word}</div>
                </div>
                ${translationsHtml}
            `;

            // å•ä¸ªé‡Šä¹‰ç‚¹å‡»åˆ‡æ¢ï¼ˆä»…å—æ§åˆ¶çš„å¡ç‰‡ç”Ÿæ•ˆï¼‰
            if (isControlled) {
                const transItems = card.querySelectorAll('.translation-item');
                transItems.forEach(el => {
                    el.addEventListener('click', () => {
                        // ç‚¹å‡»å•ä¸ªé‡Šä¹‰æ—¶ï¼ŒåŒæ­¥æ›´æ–°å…¨å±€çŠ¶æ€ï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰
                        const isCurrentHidden = el.querySelector('.meaning').classList.contains('hidden');
                        el.querySelector('.meaning').classList.toggle('hidden', !isCurrentHidden);
                    });
                });
            }

            return card;
        }

        // å¯ç”¨æ§ä»¶
        function enableAllControls() {
            document.getElementById('hideBtn').disabled = false;
            document.getElementById('showBtn').disabled = false;
            document.getElementById('shuffleBtn').disabled = false;
        }

        // æ¿€æ´»å½“å‰å•è¯
        function activateCurrentWord() {
            const cards = document.querySelectorAll('.word-card');
            if (!cards[currentIndex]) return;

            isAutoScroll = true;
            cards.forEach((card, index) => card.classList.toggle('active', index === currentIndex));
            cards[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });

            document.getElementById('feedback').textContent = 'â†ï¼šç§»è‡³å·²ç‰¢è®° | â†‘â†“/ç©ºæ ¼/Enterï¼šåˆ‡æ¢ | â†’ï¼šç§»è‡³å¾…è®°å¿†';
            document.getElementById('feedback').className = 'feedback';

            setTimeout(() => isAutoScroll = false, 500);
        }

        // æ›´æ–°ä¸‰åˆ—è®¡æ•°
        function updateCounts() {
            masteredCountEl.textContent = masteredWords.length;
            reviewCountEl.textContent = toReviewWords.length;
            untrainedCountEl.textContent = untrainedWords.length;
        }

        // åˆ‡æ¢å•è¯ï¼ˆæ¸²æŸ“åè‡ªåŠ¨æ¢å¤éšè—çŠ¶æ€ï¼‰
        function switchWord(direction) {
            if (toReviewWords.length === 0) return;

            if (direction === 'up') {
                currentIndex = Math.max(0, currentIndex - 1);
            } else if (direction === 'down') {
                currentIndex = Math.min(toReviewWords.length - 1, currentIndex + 1);
            }
            renderToReviewWords(toReviewWords); // æ¸²æŸ“åè‡ªåŠ¨æ¢å¤éšè—çŠ¶æ€
            activateCurrentWord();
        }

        // ç§»è‡³å·¦åˆ—
        function moveToMastered() {
            if (toReviewWords.length === 0) return;

            const currentWord = toReviewWords[currentIndex];
            masteredWords.push(currentWord);
            latestMasteredIndex = masteredWords.length - 1;

            toReviewWords.splice(currentIndex, 1);
            currentIndex = currentIndex >= toReviewWords.length ? Math.max(0, toReviewWords.length - 1) : currentIndex;

            renderToReviewWords(toReviewWords); // æ¸²æŸ“åè‡ªåŠ¨æ¢å¤éšè—çŠ¶æ€
            renderMasteredWords();
            updateCounts();

            if (toReviewWords.length > 0) {
                activateCurrentWord();
            } else {
                document.getElementById('feedback').textContent = 'âœ… æ‰€æœ‰å•è¯å·²åˆ†ç±»ï¼Œå·²ç‰¢è®°å•è¯å·²æ›´æ–°';
            }
        }

        // ç§»è‡³å³åˆ—
        function moveToUntrained() {
            if (toReviewWords.length === 0) return;

            const currentWord = toReviewWords[currentIndex];
            untrainedWords.push(currentWord);
            latestUntrainedIndex = untrainedWords.length - 1;

            toReviewWords.splice(currentIndex, 1);
            currentIndex = currentIndex >= toReviewWords.length ? Math.max(0, toReviewWords.length - 1) : currentIndex;

            renderToReviewWords(toReviewWords); // æ¸²æŸ“åè‡ªåŠ¨æ¢å¤éšè—çŠ¶æ€
            renderUntrainedWords();
            updateCounts();

            if (toReviewWords.length > 0) {
                activateCurrentWord();
            } else {
                document.getElementById('feedback').textContent = 'âœ… æ‰€æœ‰å•è¯å·²åˆ†ç±»ï¼Œå¾…è®°å¿†å•è¯å·²æ›´æ–°';
            }
        }

        // æ‰“ä¹±å•è¯
        function shuffleToReviewWords() {
            if (toReviewWords.length === 0) return;

            toReviewWords = [...toReviewWords].sort(() => Math.random() - 0.5);
            currentIndex = 0;

            document.getElementById('wordList').innerHTML = `
                <div style="text-align: center; padding: 80px 20px; color: #4299e1; font-size: 18px;">
                    â³ æ­£åœ¨æ‰“ä¹±å•è¯é¡ºåº...
                </div>
            `;

            setTimeout(() => {
                renderToReviewWords(toReviewWords); // æ¸²æŸ“åè‡ªåŠ¨æ¢å¤éšè—çŠ¶æ€
                activateCurrentWord();
                document.getElementById('feedback').textContent = 'ğŸ”€ å•è¯é¡ºåºå·²æ‰“ä¹±';
            }, 300);
        }

        // éšè—ä¸­é—´åˆ—æ‰€æœ‰é‡Šä¹‰æ–‡å­—ï¼ˆä¿ç•™è¯æ€§æ ‡ç­¾ï¼‰
        function hideMiddleTranslations(showTip = true) {
            isMeaningHidden = true; // æ›´æ–°å…¨å±€çŠ¶æ€
            const middleMeanings = document.querySelectorAll('[data-controlled="true"] .translation-item .meaning');
            middleMeanings.forEach(el => el.classList.add('hidden'));
            if (showTip) {
                document.getElementById('feedback').textContent = 'ğŸ™ˆ ä¸­é—´åˆ—é‡Šä¹‰å·²éšè—';
            }
        }

        // æ˜¾ç¤ºä¸­é—´åˆ—æ‰€æœ‰é‡Šä¹‰æ–‡å­—
        function showMiddleTranslations(showTip = true) {
            isMeaningHidden = false; // æ›´æ–°å…¨å±€çŠ¶æ€
            const middleMeanings = document.querySelectorAll('[data-controlled="true"] .translation-item .meaning');
            middleMeanings.forEach(el => el.classList.remove('hidden'));
            if (showTip) {
                document.getElementById('feedback').textContent = 'ğŸ‘€ ä¸­é—´åˆ—é‡Šä¹‰å·²æ˜¾ç¤º';
            }
        }

        // ç»‘å®šäº‹ä»¶
        function bindEvents() {
            const hideBtn = document.getElementById('hideBtn');
            const showBtn = document.getElementById('showBtn');
            const shuffleBtn = document.getElementById('shuffleBtn');

            // é”®ç›˜äº‹ä»¶
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    moveToMastered();
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    moveToUntrained();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    switchWord('up');
                } else if (e.key === 'ArrowDown' || e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    switchWord('down');
                }
            });

            // æŒ‰é’®äº‹ä»¶
            hideBtn.addEventListener('click', () => hideMiddleTranslations(true));
            showBtn.addEventListener('click', () => showMiddleTranslations(true));
            shuffleBtn.addEventListener('click', shuffleToReviewWords);

            // æ»šåŠ¨äº‹ä»¶
            reviewCardScroll.addEventListener('scroll', () => {
                if (isAutoScroll) return;
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    const cards = document.querySelectorAll('.word-card');
                    const scrollAreaRect = reviewCardScroll.getBoundingClientRect();
                    const centerY = scrollAreaRect.top + scrollAreaRect.height / 2;
                    let closestIndex = currentIndex;
                    let minDistance = Infinity;

                    cards.forEach((card, index) => {
                        const cardCenterY = card.getBoundingClientRect().top + card.getBoundingClientRect().height / 2;
                        const distance = Math.abs(cardCenterY - centerY);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestIndex = index;
                        }
                    });

                    if (closestIndex !== currentIndex) {
                        currentIndex = closestIndex;
                        renderToReviewWords(toReviewWords); // æ¸²æŸ“åè‡ªåŠ¨æ¢å¤éšè—çŠ¶æ€
                    }
                }, 300);
            });
        }
    </script>
</body>
</html>