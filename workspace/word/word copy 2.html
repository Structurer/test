<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•è¯èƒŒè¯µåŠ©æ‰‹ï¼ˆä¸‰åˆ—ä¼˜åŒ–ç‰ˆï¼‰</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="main-container">
        <!-- æ–°å¢ï¼šæœ€å·¦ä¾§åˆ—ï¼ˆå¯åç»­æ‰©å±•åŠŸèƒ½ï¼‰ -->
        <div class="leftmost-section">
            <div class="leftmost-title">ğŸ“‹ åŠŸèƒ½è¯´æ˜</div>
            <div class="leftmost-desc">
                ç©ºæ ¼/Enter/â†‘/â†“ï¼šåˆ‡æ¢ä¸­é—´åˆ—å•è¯<br>
                â†’ é”®ï¼šå°†å½“å‰å•è¯ç§»è‡³å³ä¾§å¾…å¤ä¹ <br>
                ç‚¹å‡»é‡Šä¹‰ï¼šéšè—/æ˜¾ç¤ºä¸­æ–‡æ„æ€
            </div>
        </div>

        <!-- ä¸­é—´åˆ—ï¼šå•è¯èƒŒè¯µåŒºï¼ˆåŸå·¦ä¾§åˆ—ï¼‰ -->
        <div class="middle-section" id="middleScrollArea">
            <h1>ğŸ“š å•è¯èƒŒè¯µåŒº</h1>
            
            <div class="control-bar">
                <button class="btn" id="hideBtn" disabled>éšè—æ‰€æœ‰é‡Šä¹‰</button>
                <button class="btn" id="showBtn" disabled>æ˜¾ç¤ºæ‰€æœ‰é‡Šä¹‰</button>
                <button class="btn reset" id="shuffleBtn" disabled>éšæœºæ‰“ä¹±é¡ºåº</button>
                <span class="word-count" id="count">å…± <span>0</span> ä¸ªå•è¯</span>
            </div>

            <!-- å•è¯åˆ—è¡¨å®¹å™¨ -->
            <div class="word-list" id="wordList">
                <div style="text-align: center; padding: 80px 20px; color: #4299e1; font-size: 20px; line-height: 2;">
                    â³ æ­£åœ¨åŠ è½½å•è¯æ•°æ®...<br>
                    è¯·ç¨å€™ï¼ŒåŠ è½½å®Œæˆåè‡ªåŠ¨æ˜¾ç¤ºå¡ç‰‡
                </div>
            </div>
        </div>

        <!-- æœ€å³ä¾§åˆ—ï¼šå¾…å¤ä¹ åŒºï¼ˆåŸå³ä¾§åˆ—ï¼‰ -->
        <div class="right-section" id="rightSection">
            <div class="input-container">
                <div class="input-title">ğŸ“Œ å¾…å¤ä¹ å•è¯</div>
                <div class="feedback" id="feedback">æŒ‰ç©ºæ ¼/Enter/â†‘/â†“åˆ‡æ¢å•è¯ï¼ŒæŒ‰â†’é”®ç§»è‡³æ­¤å¤„</div>
                <div class="progress" id="progress"> <br></div>
                <!-- å¾…å¤ä¹ å•è¯åˆ—è¡¨ -->
                <div class="review-list" id="reviewList">
                    <div style="text-align: center; padding: 40px 20px; color: #666;">æš‚æ— å¾…å¤ä¹ å•è¯</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let words = [];
        let currentIndex = 0;
        let shuffledWords = [];
        let reviewWords = []; // å³ä¾§å¾…å¤ä¹ å•è¯
        let latestReviewIndex = -1; // æ ‡è®°æœ€æ–°å¾…å¤ä¹ å•è¯ç´¢å¼•
        const middleScrollArea = document.getElementById('middleScrollArea'); // ä¸­é—´åˆ—æ»šåŠ¨å®¹å™¨
        const reviewList = document.getElementById('reviewList');
        let isAutoScroll = false;
        let scrollTimeout = null;

        // åŠ è½½JSONæ–‡ä»¶ï¼ˆç¡®ä¿ä¸å½“å‰æ–‡ä»¶åŒç›®å½•ï¼‰
        fetch('Vocabulary.json')
            .then(response => {
                if (!response.ok) throw new Error('æ–‡ä»¶ä¸å­˜åœ¨æˆ–è·¯å¾„é”™è¯¯');
                return response.json();
            })
            .then(data => {
                words = data;
                shuffledWords = [...words];
                const countSpan = document.querySelector('#count span');
                countSpan.textContent = words.length;
                document.getElementById('progress').textContent = `è¿›åº¦ï¼š1/${words.length} | å¾…å¤ä¹ ï¼š${reviewWords.length}ä¸ª`;

                renderWords(shuffledWords);
                activateCurrentWord();
                bindEvents();
                enableAllControls();
            })
            .catch(error => {
                document.getElementById('wordList').innerHTML = `
                    <div style="text-align: center; padding: 80px 20px; color: #e53e3e; font-size: 18px; line-height: 2;">
                        âŒ å•è¯æ•°æ®åŠ è½½å¤±è´¥ï¼<br><br>
                        è¯·æ£€æŸ¥ï¼š<br>
                        1. Vocabulary.json æ–‡ä»¶æ˜¯å¦åœ¨åŒæ–‡ä»¶å¤¹<br>
                        2. æ˜¯å¦é€šè¿‡ HTTP åè®®æ‰“å¼€é¡µé¢<br>
                    </div>
                `;
                document.getElementById('feedback').textContent = 'âŒ åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶';
                document.getElementById('feedback').className = 'feedback error';
            });

        // æ¸²æŸ“ä¸­é—´åˆ—å•è¯å¡ç‰‡
        function renderWords(wordArray) {
            const wordList = document.getElementById('wordList');
            wordList.innerHTML = '';
            const fragment = document.createDocumentFragment();

            wordArray.forEach((wordObj, index) => {
                const card = document.createElement('div');
                card.className = `word-card ${index === currentIndex ? 'active' : ''}`;
                card.dataset.index = index;

                // ä»…ä¿ç•™å•è¯ã€é‡Šä¹‰ã€è¯æ€§
                let translationsHtml = '<div class="translations-container">';
                wordObj.translations.forEach(trans => {
                    const meanings = trans.translation.split('ï¼›');
                    meanings.forEach(mean => {
                        translationsHtml += `
                            <div class="translation-item">
                                <span class="meaning">${mean.trim()}</span>
                                <span class="pos-tag">${trans.type}</span>
                            </div>
                        `;
                    });
                });
                translationsHtml += '</div>';

                card.innerHTML = `
                    <div class="word-header">
                        <div class="word">${wordObj.word}</div>
                    </div>
                    ${translationsHtml}
                `;

                // é‡Šä¹‰æ˜¾ç¤º/éšè—åˆ‡æ¢
                const transItems = card.querySelectorAll('.translation-item');
                transItems.forEach(el => {
                    el.addEventListener('click', () => el.classList.toggle('hidden'));
                });

                fragment.appendChild(card);
            });

            wordList.appendChild(fragment);
        }

        // æ¸²æŸ“å³ä¾§å¾…å¤ä¹ å¡ç‰‡ï¼ˆä¼˜åŒ–é¢œè‰²+è‡ªåŠ¨æ»šåˆ°åº•ï¼‰
        function renderReviewWords() {
            reviewList.innerHTML = '';
            if (reviewWords.length === 0) {
                reviewList.innerHTML = `<div style="text-align: center; padding: 40px 20px; color: #666;">æš‚æ— å¾…å¤ä¹ å•è¯</div>`;
                latestReviewIndex = -1;
                return;
            }

            const fragment = document.createDocumentFragment();
            reviewWords.forEach((wordObj, index) => {
                const card = document.createElement('div');
                // æœ€æ–°å¡ç‰‡åŠ "latest"ç±»ï¼ˆæµ…ç´«è‰²æ ·å¼ï¼‰
                card.className = `review-card ${index === latestReviewIndex ? 'latest' : ''}`;
                card.dataset.index = index;
                
                let translationsHtml = '<div class="translations-container">';
                wordObj.translations.forEach(trans => {
                    const meanings = trans.translation.split('ï¼›');
                    meanings.forEach(mean => {
                        translationsHtml += `
                            <div class="translation-item">
                                <span class="meaning">${mean.trim()}</span>
                                <span class="pos-tag">${trans.type}</span>
                            </div>
                        `;
                    });
                });
                translationsHtml += '</div>';

                card.innerHTML = `
                    <div class="word-header">
                        <div class="word">${wordObj.word}</div>
                    </div>
                    ${translationsHtml}
                `;
                fragment.appendChild(card);
            });
            reviewList.appendChild(fragment);

            // è‡ªåŠ¨æ»šåŠ¨åˆ°å³ä¾§åˆ—è¡¨æœ€åº•éƒ¨
            reviewList.scrollTop = reviewList.scrollHeight;
            setTimeout(() => {
                reviewList.scrollTop = reviewList.scrollHeight;
            }, 10);
        }

        // å¯ç”¨æ‰€æœ‰æ§ä»¶
        function enableAllControls() {
            document.getElementById('hideBtn').disabled = false;
            document.getElementById('showBtn').disabled = false;
            document.getElementById('shuffleBtn').disabled = false;
        }

        // æ¿€æ´»å½“å‰å•è¯ï¼ˆå±…ä¸­+é«˜äº®ï¼‰
        function activateCurrentWord() {
            const cards = document.querySelectorAll('.word-card');
            if (!cards[currentIndex]) return;

            isAutoScroll = true;
            // ç§»é™¤å…¶ä»–å¡ç‰‡çš„activeç±»ï¼Œç»™å½“å‰å¡ç‰‡æ·»åŠ 
            cards.forEach((card, index) => card.classList.toggle('active', index === currentIndex));
            // å¹³æ»‘æ»šåŠ¨åˆ°å½“å‰å¡ç‰‡ï¼Œä¿æŒå‚ç›´å±…ä¸­
            cards[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });

            document.getElementById('feedback').textContent = 'æŒ‰ç©ºæ ¼/Enter/â†‘/â†“åˆ‡æ¢å•è¯ï¼ŒæŒ‰â†’é”®ç§»è‡³æ­¤å¤„';
            document.getElementById('feedback').className = 'feedback';

            setTimeout(() => isAutoScroll = false, 500);
        }

        // æ›´æ–°è¿›åº¦æ˜¾ç¤º
        function updateProgress() {
            const progressEl = document.getElementById('progress');
            progressEl.textContent = `è¿›åº¦ï¼š${currentIndex + 1}/${shuffledWords.length} | å¾…å¤ä¹ ï¼š${reviewWords.length}ä¸ª`;
        }

        // åˆ‡æ¢å•è¯ï¼ˆæ”¯æŒä¸Šä¸‹é”®ï¼šä¸Šé”®ä¸Šä¸€ä¸ªï¼Œä¸‹é”®ä¸‹ä¸€ä¸ªï¼‰
        function switchWord(direction) {
            if (direction === 'up') {
                // ä¸Šé”®ï¼šç´¢å¼•å‡1ï¼Œæœ€å°ä¸º0
                currentIndex = Math.max(0, currentIndex - 1);
            } else if (direction === 'down') {
                // ä¸‹é”®/ç©ºæ ¼/Enterï¼šç´¢å¼•åŠ 1ï¼Œæœ€å¤§ä¸ºæ•°ç»„é•¿åº¦-1
                currentIndex = Math.min(shuffledWords.length - 1, currentIndex + 1);
            }
            activateCurrentWord();
            updateProgress();
        }

        // è½¬ç§»å½“å‰å•è¯åˆ°å³ä¾§å¾…å¤ä¹ åŒº
        function moveToReview() {
            const currentWord = shuffledWords[currentIndex];
            reviewWords.push(currentWord);
            latestReviewIndex = reviewWords.length - 1; // æ ‡è®°æœ€æ–°æ·»åŠ çš„å•è¯
            
            // ä»ä¸­é—´åˆ—ç§»é™¤å½“å‰å•è¯
            shuffledWords.splice(currentIndex, 1);
            // é‡æ–°æ¸²æŸ“ä¸­é—´åˆ—å’Œå³ä¾§åˆ—
            renderWords(shuffledWords);
            renderReviewWords();
            // è°ƒæ•´å½“å‰ç´¢å¼•ï¼ˆé¿å…ç§»é™¤åç´¢å¼•è¶Šç•Œï¼‰
            currentIndex = currentIndex >= shuffledWords.length ? shuffledWords.length - 1 : currentIndex;
            // è‹¥ä¸­é—´åˆ—è¿˜æœ‰å•è¯ï¼Œä¿æŒæ¿€æ´»çŠ¶æ€
            if (shuffledWords.length > 0) {
                activateCurrentWord();
            } else {
                document.getElementById('feedback').textContent = 'ğŸ‰ æ‰€æœ‰å•è¯å·²ç§»è‡³å¾…å¤ä¹ åŒºï¼';
                document.getElementById('feedback').className = 'feedback correct';
            }
            updateProgress();
        }

        // ç»‘å®šæ‰€æœ‰äº‹ä»¶
        function bindEvents() {
            const hideBtn = document.getElementById('hideBtn');
            const showBtn = document.getElementById('showBtn');
            const shuffleBtn = document.getElementById('shuffleBtn');

            // é”®ç›˜äº‹ä»¶æ ¸å¿ƒé€»è¾‘
            document.addEventListener('keydown', (e) => {
                // é¿å…è¾“å…¥æ¡†ç­‰åœºæ™¯è§¦å‘ï¼ˆè‹¥åç»­æ·»åŠ è¾“å…¥æ¡†å¯ä¿ç•™ï¼‰
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                // ä¸Šé”®ï¼šä¸Šä¸€ä¸ªå•è¯
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    switchWord('up');
                }
                // ä¸‹é”®/ç©ºæ ¼/Enterï¼šä¸‹ä¸€ä¸ªå•è¯
                else if (e.key === 'ArrowDown' || e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    switchWord('down');
                }
                // å³æ–¹å‘é”®ï¼šè½¬ç§»åˆ°å³ä¾§å¾…å¤ä¹ 
                else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (shuffledWords.length > 0) {
                        moveToReview();
                    }
                }
            });

            // æŒ‰é’®äº‹ä»¶
            hideBtn.addEventListener('click', () => {
                document.querySelectorAll('.translation-item').forEach(el => el.classList.add('hidden'));
            });
            showBtn.addEventListener('click', () => {
                document.querySelectorAll('.translation-item').forEach(el => el.classList.remove('hidden'));
            });

            // æ‰“ä¹±å•è¯é¡ºåº
            shuffleBtn.addEventListener('click', () => {
                shuffledWords = [...words].sort(() => Math.random() - 0.5);
                currentIndex = 0;
                document.getElementById('wordList').innerHTML = `
                    <div style="text-align: center; padding: 80px 20px; color: #4299e1; font-size: 18px;">
                        â³ æ­£åœ¨æ‰“ä¹±å•è¯é¡ºåº...
                    </div>
                `;
                setTimeout(() => {
                    renderWords(shuffledWords);
                    activateCurrentWord();
                    updateProgress();
                }, 300);
            });

            // ä¸­é—´åˆ—æ»šåŠ¨äº‹ä»¶ï¼šæ»šåŠ¨åè‡ªåŠ¨é€‰ä¸­å±…ä¸­çš„å¡ç‰‡
            middleScrollArea.addEventListener('scroll', () => {
                if (isAutoScroll) return;
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    const cards = document.querySelectorAll('.word-card');
                    const scrollAreaRect = middleScrollArea.getBoundingClientRect();
                    const centerY = scrollAreaRect.top + scrollAreaRect.height / 2;
                    let closestIndex = currentIndex;
                    let minDistance = Infinity;

                    cards.forEach((card, index) => {
                        const cardCenterY = card.getBoundingClientRect().top + card.getBoundingClientRect().height / 2;
                        const distance = Math.abs(cardCenterY - centerY);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestIndex = index;
                        }
                    });

                    if (closestIndex !== currentIndex) {
                        currentIndex = closestIndex;
                        cards.forEach((card, index) => card.classList.toggle('active', index === currentIndex));
                        updateProgress();
                    }
                }, 300);
            });
        }
    </script>
</body>
</html>