<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•è¯åˆ†ç±»å·¥å…·ï¼ˆæœ€ç»ˆå®Œç¾ç‰ˆï¼‰</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="grid-container">
        <!-- å·¦åˆ—ï¼šå·²ç‰¢è®°ï¼ˆå›ºå®šæ ‡é¢˜+æ»šåŠ¨å¡ç‰‡ï¼‰ -->
        <div class="column" id="masteredColumn">
            <div class="column-header">
                <div class="column-title">
                    âœ… å·²ç‰¢è®° <span id="masteredCount" class="count-badge">0</span>
                </div>
            </div>
            <div class="card-list" id="masteredCardList">
                <div class="empty-state" id="masteredEmpty">
                    æš‚æ— å•è¯<br>æŒ‰â†é”®ç§»åŠ¨è‡³æ­¤
                </div>
            </div>
        </div>

        <!-- ä¸­é—´åˆ—ï¼šå¾…å·©å›ºï¼ˆå›ºå®šæ ‡é¢˜+æ§åˆ¶æ +æ»šåŠ¨å¡ç‰‡ï¼‰ -->
        <div class="column" id="pendingColumn">
            <div class="column-header">
                <div class="column-title">
                    ğŸ“š å¾…å·©å›º <span id="pendingCount" class="count-badge">0</span>
                </div>
                <div class="control-bar">
                    <button class="btn" id="toggleMeaningBtn" disabled>éšè—é‡Šä¹‰</button>
                    <button class="btn reset" id="shuffleBtn" disabled>éšæœºé¡ºåº</button>
                </div>
            </div>
            <div class="card-list" id="pendingCardList">
                <div class="empty-state" id="pendingEmpty">
                    åŠ è½½ä¸­... è¯·ç¨å€™
                </div>
            </div>
        </div>

        <!-- å³åˆ—ï¼šå¾…è®°å¿†ï¼ˆå›ºå®šæ ‡é¢˜+æ»šåŠ¨å¡ç‰‡ï¼‰ -->
        <div class="column" id="untrainedColumn">
            <div class="column-header">
                <div class="column-title">
                    ğŸ“ å¾…è®°å¿† <span id="untrainedCount" class="count-badge">0</span>
                </div>
            </div>
            <div class="card-list" id="untrainedCardList">
                <div class="empty-state" id="untrainedEmpty">
                    æš‚æ— å•è¯<br>æŒ‰â†’é”®ç§»åŠ¨è‡³æ­¤
                </div>
            </div>
        </div>
    </div>

    <!-- æ“ä½œæç¤º -->
    <div class="control-tip">
        â†‘â†“ åˆ‡æ¢é€‰ä¸­ï¼ˆè‡ªåŠ¨å®šä½2/3å¤„ï¼‰ | â† ç§»è‡³å·²ç‰¢è®° | â†’ ç§»è‡³å¾…è®°å¿† | ç©ºæ ¼/Enter ä¸‹ä¸€ä¸ª
    </div>

    <script>
        // å…¨å±€çŠ¶æ€
        let currentIndex = 0;
        let scrollTimeout = null;
        let isMeaningHidden = false;
        const wordData = {
            mastered: [],
            pending: [],
            untrained: []
        };

        // DOMå…ƒç´ ç¼“å­˜
        const dom = {
            columns: {
                mastered: document.getElementById('masteredColumn'),
                pending: document.getElementById('pendingColumn'),
                untrained: document.getElementById('untrainedColumn')
            },
            cardLists: {
                mastered: document.getElementById('masteredCardList'),
                pending: document.getElementById('pendingCardList'),
                untrained: document.getElementById('untrainedCardList')
            },
            empties: {
                mastered: document.getElementById('masteredEmpty'),
                pending: document.getElementById('pendingEmpty'),
                untrained: document.getElementById('untrainedEmpty')
            },
            counts: {
                mastered: document.getElementById('masteredCount'),
                pending: document.getElementById('pendingCount'),
                untrained: document.getElementById('untrainedCount')
            },
            controls: {
                toggleMeaning: document.getElementById('toggleMeaningBtn'),
                shuffle: document.getElementById('shuffleBtn')
            }
        };

        // åˆå§‹åŒ–å…¥å£
        async function initApp() {
            try {
                const response = await fetch('./Vocabulary.json');
                if (!response.ok) throw new Error(`JSONåŠ è½½å¤±è´¥ï¼ˆçŠ¶æ€ç ï¼š${response.status}ï¼‰`);
                const allWords = await response.json();
                wordData.pending = [...allWords];

                renderColumn('mastered');
                renderColumn('untrained');
                renderColumn('pending');
                updateCounts();
                bindKeyboardEvents();
                bindScrollSelectClosest();
                bindControlEvents();
                window.addEventListener('resize', () => {
                    if (wordData.pending.length > 0) {
                        scrollToTwoThirds(currentIndex);
                    }
                });

                // æ¿€æ´»æ§åˆ¶æŒ‰é’®
                dom.controls.toggleMeaning.disabled = false;
                dom.controls.shuffle.disabled = false;

                if (wordData.pending.length > 0) {
                    highlightActiveCard(currentIndex);
                    scrollToTwoThirds(currentIndex);
                }
            } catch (error) {
                dom.empties.pending.innerHTML = `
                    <div class="empty-state">
                        âŒ åˆå§‹åŒ–å¤±è´¥<br>
                        ${error.message}<br>
                        è¯·æ£€æŸ¥JSONæ–‡ä»¶è·¯å¾„å’Œæ ¼å¼
                    </div>
                `;
                console.error('é”™è¯¯è¯¦æƒ…ï¼š', error);
            }
        }

        /**
         * æ¸²æŸ“æŒ‡å®šåˆ—
         */
        function renderColumn(group) {
            const cardList = dom.cardLists[group];
            const emptyEl = dom.empties[group];
            const words = wordData[group];

            cardList.innerHTML = '';

            // ç©ºçŠ¶æ€å¤„ç†
            if (words.length === 0) {
                emptyEl.style.display = 'block';
                cardList.appendChild(emptyEl);
                return;
            }
            emptyEl.style.display = 'none';

            // æ¸²æŸ“å•è¯å¡ç‰‡
            words.forEach((wordObj, index) => {
                const isActive = group === 'pending' && index === currentIndex;
                const isLatest = (group === 'mastered' || group === 'untrained') && index === words.length - 1;
                const card = createWordCard(wordObj, isActive, group, isLatest);
                cardList.appendChild(card);
            });

            // å·¦å³åˆ—æ»šåŠ¨åˆ°åº•éƒ¨
            if (group !== 'pending') {
                cardList.scrollTop = cardList.scrollHeight;
            }

            // æ¢å¤é‡Šä¹‰éšè—çŠ¶æ€
            if (group === 'pending' && isMeaningHidden) {
                hideMeanings();
            }
        }

        /**
         * åˆ›å»ºå•è¯å¡ç‰‡
         */
        function createWordCard(wordObj, isActive, group, isLatest) {
            const card = document.createElement('div');
            let cardClass = `word-card ${group}`;
            if (isActive) cardClass += ' active';
            if (isLatest) cardClass += ' new';
            card.className = cardClass;
            if (group === 'pending') card.dataset.controlled = 'true';

            let translationsHtml = '<div class="translations-container">';
            const translations = Array.isArray(wordObj.translations) ? wordObj.translations : [];
            
            if (translations.length === 0) {
                translationsHtml += `
                    <div class="translation-item">
                        <span class="meaning">æ— é‡Šä¹‰</span>
                        <span class="pos-tag">æœªçŸ¥</span>
                    </div>
                `;
            } else {
                translations.forEach(trans => {
                    const meaning = trans.translation || 'æ— é‡Šä¹‰';
                    const pos = trans.type || 'æœªçŸ¥';
                    translationsHtml += `
                        <div class="translation-item">
                            <span class="meaning">${meaning}</span>
                            <span class="pos-tag">${pos}</span>
                        </div>
                    `;
                });
            }
            translationsHtml += '</div>';

            card.innerHTML = `
                <div class="word-header">
                    <div class="word">${wordObj.word || 'æ— å•è¯'}</div>
                </div>
                ${translationsHtml}
            `;

            return card;
        }

        // åˆ‡æ¢é‡Šä¹‰æ˜¾ç¤º/éšè—
        function toggleMeanings() {
            isMeaningHidden = !isMeaningHidden;
            if (isMeaningHidden) {
                hideMeanings();
                dom.controls.toggleMeaning.textContent = 'æ˜¾ç¤ºé‡Šä¹‰';
            } else {
                showMeanings();
                dom.controls.toggleMeaning.textContent = 'éšè—é‡Šä¹‰';
            }
        }

        function hideMeanings() {
            const meanings = dom.cardLists.pending.querySelectorAll('[data-controlled="true"] .meaning');
            meanings.forEach(mean => mean.classList.add('hidden'));
        }

        function showMeanings() {
            const meanings = dom.cardLists.pending.querySelectorAll('[data-controlled="true"] .meaning');
            meanings.forEach(mean => mean.classList.remove('hidden'));
        }

        // éšæœºæ‰“ä¹±å•è¯
        function shuffleWords() {
            if (wordData.pending.length <= 1) return;
            for (let i = wordData.pending.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [wordData.pending[i], wordData.pending[j]] = [wordData.pending[j], wordData.pending[i]];
            }
            currentIndex = 0;
            renderColumn('pending');
            highlightActiveCard(currentIndex);
            scrollToTwoThirds(currentIndex);
        }

        // ç»‘å®šæ§åˆ¶æŒ‰é’®äº‹ä»¶
        function bindControlEvents() {
            dom.controls.toggleMeaning.addEventListener('click', toggleMeanings);
            dom.controls.shuffle.addEventListener('click', shuffleWords);
        }

        // æ›´æ–°è®¡æ•°
        function updateCounts() {
            dom.counts.mastered.textContent = wordData.mastered.length;
            dom.counts.untrained.textContent = wordData.untrained.length;
            const pendingLen = wordData.pending.length;
            dom.counts.pending.textContent = pendingLen > 0 
                ? `${currentIndex + 1} | ${pendingLen}` 
                : '0';
        }

        // é«˜äº®é€‰ä¸­å¡ç‰‡
        function highlightActiveCard(index) {
            const cards = dom.cardLists.pending.querySelectorAll('.word-card.pending');
            cards.forEach(card => card.classList.remove('active'));
            if (cards[index]) {
                cards[index].classList.add('active');
            }
        }

        // å®šä½é€‰ä¸­å¡ç‰‡åˆ°2/3å¤„
        function scrollToTwoThirds(index) {
            const cardList = dom.cardLists.pending;
            const cards = cardList.querySelectorAll('.word-card.pending');
            const targetCard = cards[index];
            if (!targetCard) return;

            const listHeight = cardList.clientHeight;
            const cardTop = targetCard.offsetTop;
            cardList.scrollTop = cardTop - listHeight * (2/3);
        }

        // æ»šåŠ¨é€‰ä¸­æœ€æ¥è¿‘2/3ä½ç½®çš„å¡ç‰‡ï¼ˆæ»šè½®/æ‹–åŠ¨è¿›åº¦æ¡è§¦å‘ï¼‰
        function bindScrollSelectClosest() {
            const cardList = dom.cardLists.pending;
            cardList.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    const cards = cardList.querySelectorAll('.word-card.pending');
                    if (cards.length === 0) return;

                    const listRect = cardList.getBoundingClientRect();
                    const twoThirdsY = listRect.top + listRect.height * (2/3);

                    let closestIndex = currentIndex;
                    let minDistance = Infinity;
                    cards.forEach((card, index) => {
                        const cardCenterY = card.getBoundingClientRect().top + card.offsetHeight / 2;
                        const distance = Math.abs(cardCenterY - twoThirdsY);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestIndex = index;
                        }
                    });

                    if (closestIndex !== currentIndex) {
                        currentIndex = closestIndex;
                        highlightActiveCard(currentIndex);
                        updateCounts();
                    }
                }, 50);
            });
        }

        // ç»‘å®šé”®ç›˜äº‹ä»¶ï¼ˆä¸Šä¸‹å·¦å³/ç©ºæ ¼/Enterï¼‰
        function bindKeyboardEvents() {
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                const pendingLen = wordData.pending.length;
                if (pendingLen === 0) return;

                switch (e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        moveWord('pending', 'mastered', currentIndex);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        moveWord('pending', 'untrained', currentIndex);
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        if (currentIndex > 0) {
                            currentIndex--;
                            highlightActiveCard(currentIndex);
                            scrollToTwoThirds(currentIndex);
                            updateCounts();
                        }
                        break;
                    case 'ArrowDown':
                    case ' ':
                    case 'Enter':
                        e.preventDefault();
                        if (currentIndex < pendingLen - 1) {
                            currentIndex++;
                            highlightActiveCard(currentIndex);
                            scrollToTwoThirds(currentIndex);
                            updateCounts();
                        }
                        break;
                }
            });
        }

        // ç§»åŠ¨å•è¯
        function moveWord(from, to, index) {
            const [movedWord] = wordData[from].splice(index, 1);
            wordData[to].push(movedWord);

            renderColumn(to);

            if (wordData.pending.length > 0) {
                currentIndex = Math.min(index, wordData.pending.length - 1);
                renderColumn('pending');
                highlightActiveCard(currentIndex);
                scrollToTwoThirds(currentIndex);
            } else {
                currentIndex = 0;
                renderColumn('pending');
            }

            updateCounts();
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', initApp);
    </script>
</body>
</html>