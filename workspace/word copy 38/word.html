<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å•è¯åˆ†ç±»å·¥å…·ï¼ˆæ ·å¼ä¼˜åŒ–ç‰ˆï¼‰</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="grid-container">
        <!-- å·¦åˆ—ï¼šå·²ç‰¢è®° -->
        <div class="column" id="masteredColumn">
            <div class="column-title">
                âœ… å·²ç‰¢è®° <span id="masteredCount" class="count-badge">0</span>
            </div>
            <div class="empty-state" id="masteredEmpty">
                æš‚æ— å•è¯<br>æŒ‰â†é”®ç§»åŠ¨è‡³æ­¤
            </div>
        </div>

        <!-- ä¸­é—´åˆ—ï¼šå¾…å·©å›ºï¼ˆæ ¸å¿ƒäº¤äº’åŒºï¼‰ -->
        <div class="column" id="pendingColumn">
            <div class="column-title">
                ğŸ“š å¾…å·©å›º <span id="pendingCount" class="count-badge">0</span>
            </div>
            <!-- æ–°å¢æ§åˆ¶æ ï¼ˆåŒ¹é…å‚è€ƒæ ·å¼ï¼‰ -->
            <div class="control-bar">
                <button class="btn" id="toggleMeaningBtn" disabled>éšè—é‡Šä¹‰</button>
                <button class="btn reset" id="shuffleBtn" disabled>éšæœºé¡ºåº</button>
            </div>
            <div class="empty-state" id="pendingEmpty">
                åŠ è½½ä¸­... è¯·ç¨å€™
            </div>
        </div>

        <!-- å³åˆ—ï¼šå¾…è®°å¿† -->
        <div class="column" id="untrainedColumn">
            <div class="column-title">
                ğŸ“ å¾…è®°å¿† <span id="untrainedCount" class="count-badge">0</span>
            </div>
            <div class="empty-state" id="untrainedEmpty">
                æš‚æ— å•è¯<br>æŒ‰â†’é”®ç§»åŠ¨è‡³æ­¤
            </div>
        </div>
    </div>

    <!-- æ“ä½œæç¤º -->
    <div class="control-tip">
        â†‘â†“ åˆ‡æ¢é€‰ä¸­ï¼ˆè‡ªåŠ¨å®šä½2/3å¤„ï¼‰ | â† ç§»è‡³å·²ç‰¢è®° | â†’ ç§»è‡³å¾…è®°å¿† | ç©ºæ ¼/Enter ä¸‹ä¸€ä¸ª
    </div>

    <script>
        // å…¨å±€çŠ¶æ€ï¼ˆä¿ç•™æ ¸å¿ƒé€»è¾‘ï¼Œæ–°å¢é‡Šä¹‰å’ŒéšæœºåŠŸèƒ½ï¼‰
        let currentIndex = 0;
        let scrollTimeout = null;
        let isMeaningHidden = false; // æ–°å¢ï¼šæ§åˆ¶é‡Šä¹‰æ˜¾ç¤º/éšè—
        const wordData = {
            mastered: [],
            pending: [],
            untrained: []
        };

        // DOMå…ƒç´ ç¼“å­˜ï¼ˆæ–°å¢æ§åˆ¶æŒ‰é’®ï¼‰
        const dom = {
            columns: {
                mastered: document.getElementById('masteredColumn'),
                pending: document.getElementById('pendingColumn'),
                untrained: document.getElementById('untrainedColumn')
            },
            empties: {
                mastered: document.getElementById('masteredEmpty'),
                pending: document.getElementById('pendingEmpty'),
                untrained: document.getElementById('untrainedEmpty')
            },
            counts: {
                mastered: document.getElementById('masteredCount'),
                pending: document.getElementById('pendingCount'),
                untrained: document.getElementById('untrainedCount')
            },
            controls: {
                toggleMeaning: document.getElementById('toggleMeaningBtn'),
                shuffle: document.getElementById('shuffleBtn')
            }
        };

        // åˆå§‹åŒ–å…¥å£ï¼ˆä¿ç•™æ ¸å¿ƒé€»è¾‘ï¼Œæ–°å¢æ§åˆ¶æŒ‰é’®æ¿€æ´»ï¼‰
        async function initApp() {
            try {
                const response = await fetch('./Vocabulary.json');
                if (!response.ok) throw new Error(`JSONåŠ è½½å¤±è´¥ï¼ˆçŠ¶æ€ç ï¼š${response.status}ï¼‰`);
                const allWords = await response.json();
                wordData.pending = [...allWords];

                // åˆå§‹åŒ–æ¸²æŸ“+ç»‘å®šäº‹ä»¶
                renderColumn('mastered');
                renderColumn('untrained');
                renderColumn('pending');
                updateCounts();
                bindKeyboardEvents();
                bindScrollSelectClosest();
                bindControlEvents(); // æ–°å¢ï¼šç»‘å®šæ§åˆ¶æŒ‰é’®äº‹ä»¶
                window.addEventListener('resize', () => {
                    if (wordData.pending.length > 0) {
                        scrollToTwoThirds(currentIndex);
                    }
                });

                // æ¿€æ´»æ§åˆ¶æŒ‰é’®
                dom.controls.toggleMeaning.disabled = false;
                dom.controls.shuffle.disabled = false;

                // åˆå§‹é€‰ä¸­+å®šä½
                if (wordData.pending.length > 0) {
                    highlightActiveCard(currentIndex);
                    scrollToTwoThirds(currentIndex);
                }
            } catch (error) {
                dom.empties.pending.innerHTML = `
                    <div class="empty-state">
                        âŒ åˆå§‹åŒ–å¤±è´¥<br>
                        ${error.message}<br>
                        è¯·æ£€æŸ¥JSONæ–‡ä»¶è·¯å¾„å’Œæ ¼å¼
                    </div>
                `;
                console.error('é”™è¯¯è¯¦æƒ…ï¼š', error);
            }
        }

        /**
         * æ¸²æŸ“æŒ‡å®šåˆ—ï¼ˆæ›´æ–°å¡ç‰‡ç»“æ„ï¼Œæ”¯æŒé‡Šä¹‰æ˜¾ç¤ºï¼‰
         */
        function renderColumn(group) {
            const column = dom.columns[group];
            const emptyEl = dom.empties[group];
            const words = wordData[group];

            column.innerHTML = '';

            // ç©ºçŠ¶æ€å¤„ç†
            if (words.length === 0) {
                emptyEl.style.display = 'block';
                column.appendChild(emptyEl);
                // ä¸­é—´åˆ—ä¿ç•™æ§åˆ¶æ 
                if (group === 'pending') {
                    const title = createColumnTitle(group);
                    const controlBar = createControlBar();
                    column.prepend(controlBar);
                    column.prepend(title);
                }
                return;
            }
            emptyEl.style.display = 'none';

            // æ·»åŠ åˆ—æ ‡é¢˜
            const title = createColumnTitle(group);
            column.appendChild(title);

            // ä¸­é—´åˆ—æ·»åŠ æ§åˆ¶æ 
            if (group === 'pending') {
                const controlBar = createControlBar();
                column.appendChild(controlBar);
            }

            // æ¸²æŸ“å•è¯å¡ç‰‡ï¼ˆæ”¯æŒé‡Šä¹‰ï¼‰
            words.forEach((wordObj, index) => {
                const isActive = group === 'pending' && index === currentIndex;
                const isLatest = (group === 'mastered' || group === 'untrained') && index === words.length - 1;
                const card = createWordCard(wordObj, isActive, group, isLatest);
                column.appendChild(card);
            });

            // å·¦å³åˆ—æ»šåŠ¨åˆ°åº•éƒ¨
            if (group !== 'pending') {
                column.scrollTop = column.scrollHeight;
            }

            // æ¢å¤é‡Šä¹‰éšè—çŠ¶æ€
            if (group === 'pending' && isMeaningHidden) {
                hideMeanings();
            }
        }

        // æ–°å¢ï¼šåˆ›å»ºæ§åˆ¶æ 
        function createControlBar() {
            const bar = document.createElement('div');
            bar.className = 'control-bar';
            bar.innerHTML = `
                <button class="btn" id="toggleMeaningBtn">${isMeaningHidden ? 'æ˜¾ç¤ºé‡Šä¹‰' : 'éšè—é‡Šä¹‰'}</button>
                <button class="btn reset" id="shuffleBtn">éšæœºé¡ºåº</button>
            `;
            // é‡æ–°ç»‘å®šäº‹ä»¶ï¼ˆé¿å…æ¸²æŸ“åå¤±æ•ˆï¼‰
            bar.querySelector('#toggleMeaningBtn').addEventListener('click', toggleMeanings);
            bar.querySelector('#shuffleBtn').addEventListener('click', shuffleWords);
            return bar;
        }

        /**
         * åˆ›å»ºå•è¯å¡ç‰‡ï¼ˆæ›´æ–°ä¸ºå¸¦é‡Šä¹‰çš„ç»“æ„ï¼‰
         */
        function createWordCard(wordObj, isActive, group, isLatest) {
            const card = document.createElement('div');
            let cardClass = `word-card ${group}`;
            if (isActive) cardClass += ' active';
            if (isLatest) cardClass += ' new';
            card.className = cardClass;
            if (group === 'pending') card.dataset.controlled = 'true'; // æ ‡è®°ä¸­é—´åˆ—å¡ç‰‡å¯æ§åˆ¶é‡Šä¹‰

            // æ„å»ºé‡Šä¹‰HTMLï¼ˆæ”¯æŒå¤šé‡Šä¹‰å’Œè¯æ€§ï¼‰
            let translationsHtml = '<div class="translations-container">';
            const translations = Array.isArray(wordObj.translations) ? wordObj.translations : [];
            
            if (translations.length === 0) {
                translationsHtml += `
                    <div class="translation-item">
                        <span class="meaning">æ— é‡Šä¹‰</span>
                        <span class="pos-tag">æœªçŸ¥</span>
                    </div>
                `;
            } else {
                translations.forEach(trans => {
                    const meaning = trans.translation || 'æ— é‡Šä¹‰';
                    const pos = trans.type || 'æœªçŸ¥';
                    translationsHtml += `
                        <div class="translation-item">
                            <span class="meaning">${meaning}</span>
                            <span class="pos-tag">${pos}</span>
                        </div>
                    `;
                });
            }
            translationsHtml += '</div>';

            // å¡ç‰‡å†…å®¹ï¼ˆå•è¯+é‡Šä¹‰ï¼‰
            card.innerHTML = `
                <div class="word-header">
                    <div class="word">${wordObj.word || 'æ— å•è¯'}</div>
                </div>
                ${translationsHtml}
            `;

            return card;
        }

        // æ–°å¢ï¼šåˆ‡æ¢é‡Šä¹‰æ˜¾ç¤º/éšè—
        function toggleMeanings() {
            isMeaningHidden = !isMeaningHidden;
            if (isMeaningHidden) {
                hideMeanings();
                dom.controls.toggleMeaning.textContent = 'æ˜¾ç¤ºé‡Šä¹‰';
            } else {
                showMeanings();
                dom.controls.toggleMeaning.textContent = 'éšè—é‡Šä¹‰';
            }
        }

        // æ–°å¢ï¼šéšè—ä¸­é—´åˆ—é‡Šä¹‰
        function hideMeanings() {
            const meanings = dom.columns.pending.querySelectorAll('[data-controlled="true"] .meaning');
            meanings.forEach(mean => mean.classList.add('hidden'));
        }

        // æ–°å¢ï¼šæ˜¾ç¤ºä¸­é—´åˆ—é‡Šä¹‰
        function showMeanings() {
            const meanings = dom.columns.pending.querySelectorAll('[data-controlled="true"] .meaning');
            meanings.forEach(mean => mean.classList.remove('hidden'));
        }

        // æ–°å¢ï¼šéšæœºæ‰“ä¹±ä¸­é—´åˆ—å•è¯
        function shuffleWords() {
            if (wordData.pending.length <= 1) return;
            // æ´—ç‰Œç®—æ³•æ‰“ä¹±é¡ºåº
            for (let i = wordData.pending.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [wordData.pending[i], wordData.pending[j]] = [wordData.pending[j], wordData.pending[i]];
            }
            currentIndex = 0; // é‡ç½®é€‰ä¸­ç´¢å¼•
            renderColumn('pending');
            highlightActiveCard(currentIndex);
            scrollToTwoThirds(currentIndex);
        }

        /**
         * ç»‘å®šæ§åˆ¶æŒ‰é’®äº‹ä»¶
         */
        function bindControlEvents() {
            dom.controls.toggleMeaning.addEventListener('click', toggleMeanings);
            dom.controls.shuffle.addEventListener('click', shuffleWords);
        }

        // ä»¥ä¸‹ä¸ºä¿ç•™çš„æ ¸å¿ƒé€»è¾‘ï¼ˆé«˜äº®ã€æ»šåŠ¨ã€é”®ç›˜äº‹ä»¶ç­‰ï¼‰
        function createColumnTitle(group) {
            const title = document.createElement('div');
            title.className = 'column-title';
            const count = wordData[group].length;
            const titleText = {
                mastered: 'âœ… å·²ç‰¢è®°',
                pending: 'ğŸ“š å¾…å·©å›º',
                untrained: 'ğŸ“ å¾…è®°å¿†'
            }[group];
            // ä¸­é—´åˆ—æ˜¾ç¤ºâ€œå½“å‰/æ€»æ•°â€æ ¼å¼
            const countText = group === 'pending' && count > 0 
                ? `${currentIndex + 1} | ${count}` 
                : count;
            title.innerHTML = `${titleText} <span class="count-badge">${countText}</span>`;
            return title;
        }

        function highlightActiveCard(index) {
            const cards = dom.columns.pending.querySelectorAll('.word-card.pending');
            cards.forEach(card => card.classList.remove('active'));
            if (cards[index]) {
                cards[index].classList.add('active');
            }
        }

        function scrollToTwoThirds(index) {
            const column = dom.columns.pending;
            const cards = column.querySelectorAll('.word-card.pending');
            const targetCard = cards[index];
            if (!targetCard) return;

            const columnHeight = column.clientHeight;
            const cardTop = targetCard.offsetTop;
            column.scrollTop = cardTop - columnHeight * (2/3);
        }

        function bindScrollSelectClosest() {
            const column = dom.columns.pending;
            column.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    const cards = column.querySelectorAll('.word-card.pending');
                    if (cards.length === 0) return;

                    const columnRect = column.getBoundingClientRect();
                    const twoThirdsY = columnRect.top + columnRect.height * (2/3);

                    let closestIndex = currentIndex;
                    let minDistance = Infinity;
                    cards.forEach((card, index) => {
                        const cardCenterY = card.getBoundingClientRect().top + card.offsetHeight / 2;
                        const distance = Math.abs(cardCenterY - twoThirdsY);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestIndex = index;
                        }
                    });

                    if (closestIndex !== currentIndex) {
                        currentIndex = closestIndex;
                        highlightActiveCard(currentIndex);
                        updateCounts(); // åŒæ­¥æ›´æ–°è®¡æ•°
                    }
                }, 50);
            });
        }

        function bindKeyboardEvents() {
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                const pendingLen = wordData.pending.length;
                if (pendingLen === 0) return;

                switch (e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        moveWord('pending', 'mastered', currentIndex);
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        moveWord('pending', 'untrained', currentIndex);
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        if (currentIndex > 0) {
                            currentIndex--;
                            highlightActiveCard(currentIndex);
                            scrollToTwoThirds(currentIndex);
                            updateCounts();
                        }
                        break;
                    case 'ArrowDown':
                    case ' ':
                    case 'Enter':
                        e.preventDefault();
                        if (currentIndex < pendingLen - 1) {
                            currentIndex++;
                            highlightActiveCard(currentIndex);
                            scrollToTwoThirds(currentIndex);
                            updateCounts();
                        }
                        break;
                }
            });
        }

        function moveWord(from, to, index) {
            const [movedWord] = wordData[from].splice(index, 1);
            wordData[to].push(movedWord);

            renderColumn(to);

            if (wordData.pending.length > 0) {
                currentIndex = Math.min(index, wordData.pending.length - 1);
                renderColumn('pending');
                highlightActiveCard(currentIndex);
                scrollToTwoThirds(currentIndex);
            } else {
                currentIndex = 0;
                renderColumn('pending');
            }

            updateCounts();
        }

        function updateCounts() {
            dom.counts.mastered.textContent = wordData.mastered.length;
            dom.counts.untrained.textContent = wordData.untrained.length;
            // ä¸­é—´åˆ—æ˜¾ç¤ºâ€œå½“å‰/æ€»æ•°â€
            const pendingLen = wordData.pending.length;
            dom.counts.pending.textContent = pendingLen > 0 
                ? `${currentIndex + 1} | ${pendingLen}` 
                : '0';
        }

        window.addEventListener('load', initApp);
    </script>
</body>
</html>