
## **SHA256原理详解**

* Overview 

For any message of arbitrary length, SHA256 will generate a 256-bit hash value, which is called a message digest. This digest is equivalent to an array with a length of 32 bytes and is usually represented by a hexadecimal string* with a length of 64, where 1 byte = 8 bits and the length of one hexadecimal character is 4 bits.









sha256过程概述

待哈希的消息在继续哈希计算之前首先要进行以下两个步骤：

* 对消息进行补位处理，是的最终的长度是512位的倍数
* 以512位为单位对消息进行分块为：

$$M^{(1)}, M^{(2)},..., M^{(N)}$$

* 消息区块将进行逐个处理：从一个固定的初始哈希$H^{(0)}$开始，进行以下序列的计算：

$$H^{(i)} = H^{(i-1)} + C_{M^{(i)}}(H^{(i-1)})$$

其中 $C$ 是SHA256的压缩函数， $+$ 是mod $2^{32}$ 加法，即将两个数字加在一起，如果对 $2^{32}$ 取余， $H^{(i)}$ 是消息区块的哈希值。




# 算法详细描述

SHA256的压缩函数主要对512位的消息区块和256位的中间哈希值进行操作，本质上，它是一个通过将消息区块作为密钥对中间哈希值进行加密的256位加密算法。因此，为了描述SHA256算法，有以下两方面的组件需要描述：
- SHA256压缩函数
- SHA256消息处理流程

以下的描述当中所使用到的标记如下：
- ⊕：按位异或
- ∧：按位与
- ∨：按位或
- ¬：补位
- +：相加以后对 $2^{32}$ 求余
- $R^{n}$：右移n位
- $S^{n}$：循环右移n位

以上所有的操作都是针对32位字节。






# 常量初始化

初始哈希值$H^{(0)}$取自自然数中前面8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分，并且取前面的32位。下面举个例子：$\sqrt{2}$小数部分约为0.414213562373095048，而其中

$0.414213562373095048 \approx 6 * 16^{-1} + a * 16^{-2} + 0 * 16^{-3}+...$

于是，质数2的平方根的小数部分取前32位就对应0x6a09e667。

如此类推，初始哈希值$H^{(0)}$由以下8个32位的哈希初值构成：

$H_{1}^{(0)} = 6a09e667$

$H_{2}^{(0)} = bb67ae85$

$H_{3}^{(0)} = 3c6ef372$

$H_{4}^{(0)} = a54ff53a$

$H_{5}^{(0)} = 510e527f$

$H_{6}^{(0)} = 9b05688c$

$H_{7}^{(0)} = 1f83d9ab$

$H_{8}^{(0)} = 5be0cd19$






# 消息预处理

在计算消息的哈希摘要之前需要对消息进行预处理：
- 对消息进行补码处理：假设消息$M$的二进制编码长度为$l$位，首先在消息末尾补上一位"1"，然后再补上$k$个"0"，其中$k$为下列方程的最小非负整数
$l + 1 + k \equiv 448 \pmod{512}$

举个例子，以消息"abc"为例显示补位的过程：
a,b,c对应的ASCII码和二进制编码分别如下：
|原始字符|ASCII码|二进制编码|
|---|---|---|
|a|97|01100001|
|b|98|01100010|
|c|99|01100011|

因此，原始信息"abc"的二进制编码为：01100001 01100010 01100011，第一步补位，首先在消息末尾补上一位"1"，结果为：01100001 01100010 01100011 1；然后进行第二步的补位，因为$l = 24$，可以得到$k = 423$，在第一步补位后的消息后面再补423个"0"，结果如下：
$01100001 01100010 01100011 1\underbrace{00...0}_{423}$

最后还要在上述字节串后面继续进行补码，这个时候补的是原消息"abc"的二进制长度$l = 24$的64位二进制表示形式，补完以后的结果如下：
$01100001 01100010 01100011 1\underbrace{00...0}_{423}\underbrace{00...011000}_{64}$



### 消息二进制位数
- 最终补完以后的消息二进制位数长度是512的倍数。

### 注意事项
- 不管原来的消息长度是多少，即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512位。另外，考虑到最后要将消息长度$l$转换为64位二进制编码，因此，长度必须小于$2^{64}$，绝大多数情况下，这个足够大了。

### 消息分块
- 将补码处理后的消息以512位为单位分块为：$M^{(1)}, M^{(2)},..., M^{(N)}$，其中第$i$个消息块的前32位表示为：$M_{0}^{(i)}$，后面32位为：$M_{1}^{(i)}$，以此类推，最后32位的消息块可表示为：$M_{15}^{(i)}$。采用Big endian约定对数据进行编码，即认为第一个字节是最高位字节，因此，对于每一个32位字节，最左边的比特是最大的比特位。



这段内容主要讲述了消息预处理后的相关要点以及消息分块的规则：

### 消息二进制位数
- 最终补完以后的消息二进制位数长度是512的倍数。

### 注意事项
- 不管原来的消息长度是多少，即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512位。另外，考虑到最后要将消息长度$l$转换为64位二进制编码，因此，长度必须小于$2^{64}$，绝大多数情况下，这个足够大了。

### 消息分块
- 将补码处理后的消息以512位为单位分块为：$M^{(1)}, M^{(2)},..., M^{(N)}$，其中第$i$个消息块的前32位表示为：$M_{0}^{(i)}$，后面32位为：$M_{1}^{(i)}$，以此类推，最后32位的消息块可表示为：$M_{15}^{(i)}$。采用Big endian约定对数据进行编码，即认为第一个字节是最高位字节，因此，对于每一个32位字节，最左边的比特是最大的比特位。




### 计算中间哈希值
- 计算第$i$个中间哈希值$H^{(i)}$，通过以下方式：
    - $H_{1}^{(i)} \leftarrow a + H_{1}^{(i - 1)}$
    - $H_{2}^{(i)} \leftarrow b + H_{2}^{(i - 1)}$
    - $\vdots$
    - $H_{8}^{(i)} \leftarrow h + H_{8}^{(i - 1)}$
- $H^{(N)} = (H_{1}^{(N)}, H_{2}^{(N)},..., H_{8}^{(N)})$为最终需要的哈希$M$。

### 逻辑函数定义
- SHA256算法中所使用到的6个逻辑函数如下，每个函数都对32位字节进行操纵，并输出32位字节：
    - $Ch(x, y, z) = (x \land y) \oplus (\neg x \land z)$
    - $Maj(x, y, z) = (x \land y) \oplus (x \land z) \oplus (y \land z)$
    - $\Sigma_{0}(x) = S^{2}(x) \oplus S^{13}(x) \oplus S^{22}(x)$
    - $\Sigma_{1}(x) = S^{6}(x) \oplus S^{11}(x) \oplus S^{25}(x)$
    - $\sigma_{0}(x) = S^{7}(x) \oplus S^{18}(x) \oplus R^{3}(x)$
    - $\sigma_{1}(x) = S^{17}(x) \oplus S^{19}(x) \oplus R^{10}(x)$

### 扩展消息块计算
- 扩展消息块$W_{0}, W_{1},..., W_{63}$通过以下方式进行计算：
    - $W_{j} = M_{j}^{(i)}$ for $j = 0, 1,..., 15$
    - For $j = 16 \to 63$
    - $W_{j} \leftarrow \sigma_{1}(W_{j - 2}) + W_{j - 7} + \sigma_{0}(W_{j - 15}) + W_{j - 16}$

这些内容是SHA256算法的核心部分，逻辑函数用于对数据进行复杂的变换和处理，中间哈希值的计算以及扩展消息块的生成都是为了最终生成哈希值，保证数据的完整性和安全性。在密码学、区块链等领域，这些算法和计算方式起着至关重要的作用。例如，在区块链中，通过类似的哈希算法确保交易数据的不可篡改和安全性，每一个区块的哈希值都依赖于前一个区块的哈希值和当前区块的数据，任何对数据的修改都会导致哈希值的变化，从而被系统检测到。









